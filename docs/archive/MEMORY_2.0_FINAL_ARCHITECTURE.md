# üß† Memory Engineering 2.0 - Final Architecture

## üéØ Core Philosophy
**Zero Risk. Minimal Complexity. Maximum AI Efficiency.**

## üèóÔ∏è Architecture: One Collection, Four Memory Classes

### MongoDB Collection: `memories`
```javascript
{
  _id: ObjectId,
  projectId: String,
  
  // Classification
  memoryClass: "core" | "working" | "insight" | "priority",
  memoryType: "pattern" | "context" | "event" | "learning" | "urgency",
  
  // Flexible content based on class
  content: {
    // For core memories (6 files)
    fileName: String,
    markdown: String,
    
    // For working memories
    event: {
      timestamp: Date,
      action: String,
      context: Object,
      solution: String,
      duration: Number
    },
    
    // For insights
    insight: {
      pattern: String,
      confidence: Number,
      evidence: [ObjectId]
    },
    
    // For priorities
    priority: {
      issue: String,
      severity: String,
      deadline: Date,
      blockers: [String]
    }
  },
  
  // Search and retrieval
  contentVector: Array,     // voyage-3-large embeddings (1024 dims)
  searchableText: String,   // Concatenated for text search
  
  // Metadata
  metadata: {
    importance: Number,     // 1-10
    freshness: Date,       // Last access
    accessCount: Number,
    autoExpire: Date,      // TTL for working memories
    tags: [String],
    codeReferences: [{
      file: String,
      line: Number,
      snippet: String
    }]
  }
}
```

## üìä The 4 Memory Classes

### 1. Core Memories (Permanent Knowledge)
**The 6 foundational files:**
- `projectbrief.md` - Project vision and goals
- `systemPatterns.md` - Architecture and code patterns
- `activeContext.md` - Current sprint/task focus
- `techContext.md` - Stack and dependencies
- `progress.md` - Completed work and lessons
- `codebaseMap.md` - File structure and modules

**Characteristics:**
- Never expire
- High importance (8-10)
- Updated occasionally
- Foundation for all context

### 2. Working Memories (Daily Events)
**What happens during coding:**
- Debug sessions with solutions
- Implementation approaches
- Code reviews and refactoring
- Performance optimizations

**Characteristics:**
- Auto-expire after 30 days (TTL)
- Medium importance (5-7)
- High velocity creation
- Temporal relevance

### 3. Insight Memories (Discovered Patterns)
**Auto-generated from analysis:**
- Recurring error patterns
- Successful approaches
- Performance bottlenecks
- Team coding habits

**Characteristics:**
- Generated by aggregation pipelines
- Confidence scored
- Evidence-based
- Improve over time

### 4. Priority Memories (Urgent Context)
**What needs attention NOW:**
- Production bugs
- Deadline pressures
- Blocking issues
- High-stress debugging

**Characteristics:**
- Influence AI tone/approach
- Short-lived but high impact
- Emotional context aware
- Help prioritize assistance

## üöÄ MongoDB Indexes

```javascript
// 1. Compound indexes for queries
db.memories.createIndex({ projectId: 1, memoryClass: 1, "metadata.freshness": -1 })
db.memories.createIndex({ projectId: 1, "metadata.importance": -1 })

// 2. Vector search index
db.memories.createSearchIndex("memory_vectors", {
  type: "vectorSearch",
  fields: [{
    type: "vector",
    path: "contentVector",
    numDimensions: 1024,
    similarity: "cosine"
  }]
})

// 3. Text search index
db.memories.createSearchIndex("memory_text", {
  mappings: {
    dynamic: false,
    fields: {
      searchableText: { type: "string" },
      "metadata.tags": { type: "string" }
    }
  }
})

// 4. TTL for auto-cleanup
db.memories.createIndex({ "metadata.autoExpire": 1 }, { expireAfterSeconds: 0 })
```

## üíé The $rankFusion Query

```javascript
async function getMemoryContext(query) {
  const embedding = await voyage.embed(query, { model: "voyage-3-large" });
  
  return await db.memories.aggregate([
    {
      $rankFusion: {
        input: {
          pipelines: {
            // Semantic understanding (30%)
            semantic: [
              {
                $vectorSearch: {
                  index: "memory_vectors",
                  path: "contentVector",
                  queryVector: embedding,
                  filter: { projectId },
                  limit: 30
                }
              }
            ],
            
            // Recent context (20%)
            recent: [
              {
                $match: {
                  projectId,
                  "metadata.freshness": { $gte: new Date(Date.now() - 7*24*60*60*1000) }
                }
              },
              { $sort: { "metadata.freshness": -1 } },
              { $limit: 20 }
            ],
            
            // Proven patterns (30%)
            patterns: [
              {
                $search: {
                  index: "memory_text",
                  text: { query, path: "searchableText" }
                }
              },
              {
                $match: { "metadata.importance": { $gte: 8 } }
              },
              { $limit: 15 }
            ],
            
            // Urgent issues (20%)
            priority: [
              {
                $match: {
                  memoryClass: "priority",
                  "content.priority.resolution": null
                }
              },
              { $sort: { "metadata.urgency": -1 } },
              { $limit: 5 }
            ]
          }
        },
        combination: {
          weights: {
            semantic: 0.3,
            recent: 0.2,
            patterns: 0.3,
            priority: 0.2
          }
        }
      }
    },
    { $limit: 10 }
  ]);
}
```

## üé® Implementation Phases

### Phase 1: Deprecation (Week 1)
- Remove context engineering features
- Delete 5 files, simplify types
- 40% code reduction
- Update documentation

### Phase 2: Core Implementation (Week 2)
- Single collection setup
- 4 memory class schemas
- Index creation
- Basic CRUD operations

### Phase 3: Intelligence Layer (Week 3)
- $rankFusion search
- Auto-insight generation
- Memory lifecycle (decay, reinforcement)
- Priority handling

### Phase 4: Polish & Ship (Week 4)
- Performance optimization
- Developer experience
- Documentation & examples
- npm publish

## üìà Success Metrics

### Performance
- Query latency: <50ms
- Memory retrieval accuracy: >95%
- Scale: 1M+ memories per project
- Auto-cleanup: 30-day TTL for working memories

### Developer Impact
- Context relevance: 10x improvement
- Bug resolution: 40% faster
- Pattern discovery: Automatic
- Zero configuration required

## üîë Key Decisions

### Why One Collection?
- Simpler schema management
- Unified search across all memories
- Easier backup/restore
- Better performance with proper indexes

### Why voyage-3-large?
- 80% of memories are English descriptions
- Better for natural language queries
- Still handles code reasonably well
- 1024 dimensions perfect for MongoDB

### Why 4 Classes Instead of 5?
- Practical vs academic
- Maps to developer needs
- Priority memory fills critical gap
- Simpler to understand and use

## üöÄ Why This Architecture Wins

1. **Simplicity**: One collection, clear structure
2. **Flexibility**: Handles all memory needs
3. **Performance**: Optimized indexes, smart queries
4. **MongoDB Native**: Showcases unique features
5. **Developer Focused**: Solves real problems
6. **AI Optimized**: Perfect context delivery
7. **Open Source**: Community-driven improvement

---

*"This is not just another memory system. This is THE memory system that makes AI coding assistants actually useful."*